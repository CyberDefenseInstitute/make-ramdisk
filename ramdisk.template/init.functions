#!/bin/sh

voldir=/dev/disk/by-label
rr=/realroot
init="/sbin/init"
udevl="err"
drivers="sd-mod,sr-mod,ide-disk,ide-cd,usb-storage,dm-mod,usbhid"
dev_tmout=35
dhcp_delay=5
iface_upwait=10
max_loop=64
arch="$(uname -m || true)"
kver="$(uname -r || true)"
wpa_conf="/etc/wpa.conf"

#
# functions
#
log () {
  test -n "$quiet" || echo "$@"
}

init_udev () {
  local udev_db
  log -n "udev "
  if test -d /run ;then
    test -d /run/udev || mkdir -p /run/udev
  else
    test -d /dev/.udev || mount -t tmpfs -o mode=755,size=2M none /dev
    mkdir -p /dev/.udev/db/ /dev/.udev/queue/
  fi
  test -e /dev/null || mknod /dev/null c 1 3
  test -e /dev/console || mknod /dev/console c 5 1
  test -e /dev/tty || mknod /dev/tty c 5 0
  echo "udev_log=\"$udevl\"" >/etc/udev/udev.conf
  test -z "$no_volid" || echo "# Disabled with no_volid" >/etc/udev/rules.d/vol_id.rules
  echo >/proc/sys/kernel/hotplug
  test -n "`getpids udevd`" || udevd --daemon
  log -n "generating devices "
  udevadm trigger
  udevadm settle
  log
}

init_pkcs11() {
  mkdir -p /var/run/openct /var/run/pcscd
  openct-control init
}

stop_pkcs11() {
  killall pcscd || true
  test ! -e /var/run/openct/status || openct-control shutdown
}

init_ramdisk () {
  mkdir -p /sys /proc /tmp $rr /etc/udev /var/log /mnt /parts /usr/sbin /usr/bin /sbin /dev/pts
  test -d /run || { mkdir -p /run ; mount -t tmpfs -o nosuid,noexec,mode=0755 shmfs /run ; }
  echo -n >>/etc/fstab
  test -e /etc/mtab -o -L /etc/mtab || ln -s /proc/mounts /etc/mtab
  test -d /proc/$$ || mount -t proc none /proc 
  test -d /sys/kernel || mount -t sysfs none /sys
  echo -n '[9;0]'
  test ! -x /bin/busybox || /bin/busybox --install -s || false
}

init_wifi() {
  local ifdir real_wpa_conf
  which wpa_supplicant >/dev/null || return 0
  real_wpa_conf="$(prepare_file "$wpa_conf")"
  test -e "$real_wpa_conf" || return 0
  test -n "$wifi_iface" || {
    for ifdir in /sys/class/net/*;do
      test ! -e "$ifdir/phy80211" || {
        wifi_iface="${ifdir##*/}"
        break
      }
    done
  }
  test -n "$wifi_iface" || {
    echo "80211 interface not found" >&2
    return 1
  }
  log "running wpa_supplicant on $wifi_iface using $real_wpa_conf"
  wpa_supplicant -B -Dnl80211 -i"$wifi_iface" -c"$real_wpa_conf"
}

init_modprobe () {
  local moda modalias mod
  log -n "loading drivers: $drivers"
  for mod in $(str_split , $drivers);do
    modprobe $qswitch $mod || true
  done

  if test -r /etc/modules.preload;then
    log -n "Pre-loading modules: "
    while read module ;do
      log -n $module
      modprobe $qswitch $module || true
    done < /etc/modules.preload
    log
  fi

  enter_stage pci
  log -n " PCI"
  for moda in /sys/bus/pci/devices/*/modalias;do
    log -n .
    read modalias <$moda
    modprobe $qswitch $modalias || true
  done
  log
}

next_mark () {
  case $1 in
    "/") echo "-";;
    "-") echo "\\";;
    "\\") echo "|";;
    "|") echo "/";;
    *) echo "/";;
  esac
}

wait_exist() {
  local device="$1"
  local timeout="${2:-$dev_tmout}"
  local devinfo="[$device"
  while test ! -e "$device" -a "$timeout" != "0";do
    mark="$(next_mark $mark)"
    echo -n "$devinfo$mark"
    devinfo=""
    sleep 1
    timeout=$(($timeout-1))
  done
  test -n "$devinfo" || echo "]"
}

fs_type() {
  blkid -o value -s TYPE "$1" || true
}

fs_uuid() {
  blkid -o value -s UUID "$1" || true
}

list_partitions() {
  local major minor blocks name devs spc=""
  while read major minor blocks name; do
    test -n "$name" -a -e "/dev/$name" || continue
    echo -n "$spc/dev/$name"
    spc=" "
  done < /proc/partitions
  test -z "$spc" || echo
}

prepare_file_smb() {
  local wrk="${1#smb://}" user="" host share file mnt
  host="${wrk%%/*}"
  case "$host" in
    *@*)
      user="${host%@*}"
      host="${host#*@}"
    ;;
  esac
  wrk="${wrk#*/}"
  share="${wrk%%/*}"
  file="${wrk#*/}"
  mnt="$(mktemp -d /mnt/smb-XXXXXX)"
  test -n "$user" || { echo -n "User for //$host/$share: " >&2 ; read user ; }
  mount.cifs "//$host/$share" "$mnt" -o "user=$user,noperm" >&2
  echo "$mnt/$file"
}

prepare_file_tftp() {
  local file="${1#tftp://}" dst="${2:-$(mktemp /tmp/tftp-XXXXXX)}" host
  host="${file%%/*}"
  file="${file#*/}"
  tftp -g -l "$dst" -r "$file" "$host" >&2
  echo "$dst"
}

prepare_file_wget() {
  local src="$1" dst="${2:-$(mktemp /tmp/wget-XXXXXX)}" src_comp dst_dir comp_pat
  local src_proto="${src%%://*}"
  local src_hostpath="${src#*://}"
  case "$src" in
    *"*"*)
      dst_dir="${dst%/*}"
      comp_pat="${src##*/}"
      src_dir="${src%/*}"
      for src_comp in $(wget -O - "$src_dir/" | grep -o '"[^"[:space:]]*"' | cut -f2 -d'"');do
        case "$src_comp" in $comp_pat)
          wget -O "$dst_dir/$src_comp" "$src_dir/$src_comp" >&2
          echo "$dst_dir/$src_comp"
          ;;
        esac
      done
      ;;
    *)
      wget -O "$dst" "$1" >&2
      echo "$dst"
    ;;
  esac
}

prepare_file_pkcs15() {
  local fname="${1#pkcs15://}" pcscd_pid temp_file="${2:-$(mktemp /tmp/pkcs15.XXXXXX)}"
  mkdir -p /var/run/pcscd
  pcscd -x >&2
  pkcs15-tool -w -R "$fname" -o "$temp_file" >&2 && { clear >&2 || true; }
  test ! -e /var/run/pcscd/pcscd.pid || {
    read pcscd_pid < /var/run/pcscd/pcscd.pid
    test ! -e "/proc/$pcscd_pid/exe" || kill "$pcscd_pid"
  }
  echo "$temp_file"
}

prepare_file_dev() {
  local dev_f="$1"
  prepare_dev "${dev_f%%:*}" >&2
  local mpt="$(mktemp -d /mnt/prep-XXXXXX)"
  mount -o ro -t $prepared_filesystem $prepared_device $mpt
  echo "$mpt/${dev_f#*:}"
}

prepare_file() {
  local src="$1" dst="$2"
  case "$src" in 
    smb://*) prepared_file="$(prepare_file_smb "$@")";;
    tftp://*) prepared_file="$(prepare_file_tftp "$@")" ;;
    http://*) prepared_file="$(prepare_file_wget "$@")" ;;
    ftp://*) prepared_file="$(prepare_file_wget "$@")" ;;
    pkcs15://*) prepared_file="$(prepare_file_pkcs15 "$@")" ;;
    @*:*|/dev/*:*|UUID=*:*|LABEL=*:*) prepared_file="$(prepare_file_dev "$1")" ;;
    /*) prepared_file="$1";;
    *)
       echo "Unknown prepare_file: '$1'" >&2
       return 1
    ;;
  esac
  if test -n "$dst" -a ! "x$dst" = "x$prepared_file";then
    case "$dst" in
      *"*"*) echo $prepared_file;;
      *)
        echo -n "Copying '$prepared_file' to '$dst'".. >&2
        cp "$prepared_file" "$dst"
        echo -n "ok." >&2
        echo "$dst"
      ;;
    esac
  else echo "$prepared_file";fi
}

load_loop() {
  local major dev
  while read major dev; do
    test "'loop'" != "'$dev'" || {
      loop_loaded=1
      break
    }
  done < /proc/devices
  test "1" = "$loop_loaded" || modprobe loop ${max_loop:+max_loop=$max_loop}
  loop_loaded=1
}

prepare_dev () {
  local _dev="$1"
  local timeout="$2"
  local cryptkey="$gck"
  local _cryptkey udev_pids
  local _l_dev
  case "$_dev" in
    LABEL=*) _dev="@${_dev#LABEL=}";;
    UUID=*) _dev="/dev/disk/by-uuid/${_dev#UUID=}";;
  esac
  if test -z "${_dev%@*}";then
    if _l_dev="$(blkid -L "${_dev#@}")";then
      _dev="$_l_dev"
    else 
      _dev="$voldir/${_dev#@}"
    fi
  fi
  wait_exist "$_dev" "$timeout"
  if test -e "$_dev";then
    local fileext="${_dev##*.}"
    if ! test -b "$_dev";then
      test -n "$loop_loaded" || load_loop
      while ! test -e /dev/loop0; do sleep 1;done
      local loopdev=`losetup -f`
      losetup $loopdev "$_dev"
      _dev="$loopdev"
    fi
    wait_exist "$_dev"
    local _fs="$(fs_type "$_dev")"
    if test "$_fs" = "crypto_LUKS" -o "$_fs" = "swap" && cryptsetup isLuks "$_dev";then
      modprobe dm-crypt
      if test -z "$cryptkey" ;then
        if ! cryptsetup -t 20 $cryptopts luksOpen "$_dev" "${_dev##*/}-dec";then
          echo -n "{$?} $_dev ck: "
          read cryptkey
        fi
      fi
      if test -n "$cryptkey";then
        cryptsetup -d "$(prepare_file "$cryptkey")" $cryptopts luksOpen "$_dev" "${_dev##*/}-dec"
      fi
      _dev="/dev/mapper/${_dev##*/}-dec"
      wait_exist "$_dev"
      _fs="$(fs_type $_dev)"
    fi
    test -n "$_fs" -o "$fileext" != "sfs" || _fs=squashfs
    test "$_fs" != "LVM2_member" -o ! -x /sbin/lvm || refresh_lvm
    prepared_device="$_dev"
    prepared_filesystem="$_fs"
  else
    return 1
  fi
}

decrypt_pkcs11() {
  local enc_file="$1" inkey="${2:-slot_01}"
  openssl rsautl -engine pkcs11 -keyform engine -inkey $inkey -decrypt -in "$enc_file"
}

find_ifaces() {
  local name="${1:-all}" ifdir="" curif=""
  for ifdir in /sys/class/net/*;do
    echo -n "${curif:+ }"
    curif="${ifdir##*/}"
    test "$curif" != "lo" || continue
    test "$name" != "all" || echo -n "$curif"
    test "$curif" != "$name" || echo -n "$curif"
  done
}

ip_link_up() {
  local iface="$1" up_addr="169.254.1.1:::255.255.0.0:"
  if test "x$iface" = "xlo"; then up_addr="127.0.0.1::::"; fi
  if type ip >/dev/null; then ip link set up dev "$iface"
  else ipconfig -d $up_addr:$iface:off;fi
}

is_iface_up() {
  local iface="$1"
  if type ip >dev/null;then
    ip link show dev "$iface" | grep -v NO-CARRIER | grep -q UP
    return $?
  else
    case "$(cat /sys/class/net/$iface/operstate)" in
      up) return 0;;
      *) return 1;;
    esac
  fi
}

wait_ifup() {
  local  ifaces="$(find_ifaces "$1")" iface="" maxwait="$iface_upwait"
  test -n "$ifaces" || return 0
  echo -n "Waiting for $ifaces to come up.." >&2
  for iface in $ifaces;do ip_link_up "$iface" ; done
  while test "$maxwait" -gt 0;do
    for iface in $ifaces;do
      if is_iface_up "$iface";then
        echo "Ok ($iface)" >&2
        echo $iface
        return 0
      fi
    done
    maxwait="$(($maxwait-1))"
    echo -n " $maxwait" >&2
    sleep 1
  done
  echo "No interface ($ifaces) become up in $maxwait seconds" >&2
  return 1
}

get_dhcp_lease() {
  local iface="$1"
  if type udhcpc >/dev/null;then
    udhcpc ${dhcp_delay:+-T $dhcp_delay -t 2} -n -q ${iface:+-i $iface}
    return $?
  else
    ipconfig -o ${dhcp_delay:+-t $dhcp_delay} -d ${iface:-all}
    return $?
  fi
}

init_net () {
  log -n "net "
  local ip="$1" i iface_up
  local dns netconf IPV4ADDR IPV4BROADCAST IPV4DNS0 IPV4DNS1 IPV4GATEWAY IPV4NETMASK NISDOMAIN DEVICE DNSDOMAIN iface ROOTSERVER #HOSTNAME

  ip_link_up lo
  case "$ip" in
    *:*:*:*:*:*:*) ipconfig -o ${dhcp_delay:+-t $dhcp_delay} -d $ip ;;
    *:dhcp)
      iface="${ip%:dhcp}"
      wait_ifup "$iface"
      get_dhcp_lease "$iface"
    ;;
    dhcp)
      iface_up=$(wait_ifup all)
      echo -n "DHCP.."
      for i in 9 8 7 6 5 4 3 2 1 FAIL;do
        echo -n "$i "
        if get_dhcp_lease $iface_up;then break;fi
      done
      echo
      test "$i" != FAIL
    ;;
  esac
  for netconf in /tmp/net-*.conf;do
    test -e "$netconf" || continue
    . $netconf
    test -z "$DNSDOMAIN" || echo "domain $DNSDOMAIN" >>/etc/resolv.conf
    test -z "$ROOTSERVER" -o "$ROOTSERVER" = "0.0.0.0" || echo "$ROOTSERVER server" >>/etc/hosts
    for dns in $IPV4DNS0 $IPV4DNS1;do
      test "$dns" = "0.0.0.0" || echo "nameserver $dns" >>/etc/resolv.conf
    done
  done
  log
}

getpids() {
  local progname="$1" pids="" cmd pid others stat
  for stat in /proc/[0-9]*/stat;do
    if read pid cmd others <$stat;then
      test "($progname)" != "$cmd" || pids="$pids${pids:+ }$pid"
    fi
  done
  echo "$pids"
}

killall () {
  local progname="$1" pid
  pid="`getpids $progname`"
  test -z "$pid" || kill $pid
}

get_mount_type () {
  local mpt="$1"
  local dev pnt type opts other mnt_type
  while read dev pnt type opts other;do
    test "$pnt" != "$mpt" || mnt_type="$type"
  done </proc/mounts
  echo $mnt_type
}

finalize_boot () {
  killall udevd
  local migrate_list src mpt opts
  while read src mpt opts; do
    case $mpt in
      /dev|/sys|/live*|/proc|/run) if test -e $rr$mpt || mkdir -p $rr$mpt;then migrate_list="$mpt $migrate_list"; fi;;
    esac
  done </proc/mounts

  log -n "Migrating:"
  for mpt in $migrate_list;do
    log -n " $mpt"
    mount -o move $mpt $rr$mpt
  done
  test ! -e /etc/resolv.conf || test -e $rr/etc/resolv.conf || test ! -w $rr/etc || cat /etc/resolv.conf >$rr/etc/resolv.conf || true
  log

  enter_stage runinit
  if test -L "$rr$init" || test -x $rr$init -a -f $rr$init;then
    log "End of ramdisk: run-init $rr $init"
    test -z "$brk" || return
    test -n "$quiet" || set -x
    cd "$rr"
    exec run-init -c dev/console $rr $init
  else
    echo "Refusing to run-init: '$init' on '$rr' is not executable file"
  fi
}

add_chained_mpt() {
  chained_parts="$1${chained_parts:+ $chained_parts}"
}

mount_device() {
  local device="$1" mpt="$2"
  prepare_dev $device
  if test "$prepared_filesystem" = "ntfs" -a -x "$(which ntfs-3g)";then
    ntfs-3g -o "${mntopts:-rw}" $prepared_device $mpt
  else
    mount -o "${mntopts:-ro}" -t $prepared_filesystem $prepared_device $mpt
  fi
}

chained_mount () {
  local devpath="$1" local mpt="$2" lastpath_file
  local uri_host uri_share uri_user uri_file

  case "$devpath" in
    smb://*)
      mkdir -p /live

      uri_host="${devpath#smb://}"
      uri_share="${uri_host#*/}"
      uri_host="${uri_host%%/*}"
      uri_user="${uri_host%%@*}"
      uri_host="${uri_host#*@}"
      uri_file="${uri_share#*:}"
      uri_share="${uri_share%%:*}"
      test ! "x$uri_host" = "x$uri_user" || uri_user=""
      test ! "x$uri_file" = "x$uri_share" || uri_file=""

      if test -z "$uri_file";then
        mkdir -p "$mpt"
        mount.cifs "//$uri_host/$uri_share" -o "noperm${uri_user:+,user=$uri_user}" "$mpt"
      else
        devpath_src=/live
        test -z "$lcount" || {
          mkdir -p /live$lcount
          mount -o move /live /live$lcount
        }
        mkdir -p /live
        lcount=$((${lcount:-0}+1))
        mount.cifs "//$uri_host/$uri_share" -o "noperm${uri_user:+,user=$uri_user}" "$devpath_src"
        chained_mount ":$uri_file" "$mpt"
      fi
    ;;
    *:*)
      local prepath="${devpath%%:*}"
      devpath="${devpath#*:}"
      
      test -z "$prepath" || {
        if test "$live_is_tmpfs" = "1";then
          devpath_src="/live/mnt/${prepath##*/}"
          mkdir -p "$devpath_src"
          chained_mount "$prepath" "$devpath_src"
        else
          devpath_src=/live
          test -z "$lcount" || {
            mkdir -p /live$lcount
            mount -o move /live /live$lcount
          }
          mkdir -p /live
          chained_mount $prepath /live
          lcount=$((${lcount:-0}+1))
        fi
      }
      case "$devpath" in
        *"*"*)
          local idx=0 n
          for lastpath_file in "$devpath_src"/$devpath;do
            n="${lastpath_file##*/}"
            test -z "$live_is_tmpfs" || {
              echo -n "Copying $n .."
              cp "$lastpath_file" /live
              echo "ok."
              lastpath_file="/live/$n"
            }
            n="${n%.[0-9a-z][0-9a-z]*}"
            log "Mounting $lastpath_file to ${mpt}-$idx-$n"
            mkdir -p "${mpt}-$idx-$n"
            chained_mount $lastpath_file ${mpt}-$idx-$n
            idx=$(($idx+1))
          done
        ;;
        *)
          lastpath_file="$devpath_src/$devpath"
          test -z "$live_is_tmpfs" || {
            n="${lastpath_file##*/}"
            echo -n "Copying $n .."
            cp "$lastpath_file" /live
            echo "ok."
            lastpath_file="/live/$n"
          }
          chained_mount "$lastpath_file" $mpt
        ;;
      esac
      ;;
    *)
      case "$devpath" in
        mem) mount -t tmpfs -o mode=755 none $mpt;;
        [0-9]*[kmgKMG]) mount -t tmpfs -o mode=755 -o size=$devpath none $mpt ;;
	virt9p-*) mount -t 9p -o trans=virtio,version=9p2000.L ${devpath#virt9p-} $mpt;;
        *) mount_device "$devpath" "$mpt";;
      esac
      case "$mpt" in /parts/*) add_chained_mpt "$mpt";; esac
    ;;
  esac
}

str_split() {
  local IFS_save="$IFS" part split_chars="$1" parts="$2" spc=""
  IFS="$split_chars"
  for part in $parts;do
    IFS="$IFS_save"
    echo -n "$spc$part"
    spc=" "
  done
  test -z "$spc" || echo
}

basename() {
  local name="$1" suffix="$2"
  while test "x$name" != "x${name%/}" -a -n "${name%/}"; do name="${name%/}";done
  test "${#name}" = 1 || name="${name##*/}" 
  test -z "$suffix" || name="${name%$suffix}" 
  echo "$name"
}

mount_rootpart () {
  local rootpart="$1" nfs_path nfs_host
  rcount=${rcount:-0}
  rcount=$(($rcount+1))

  local mpt=/parts/$rcount
  mkdir -p $mpt

  log "Mount root part '$rootpart' to $mpt"

  case "$rootpart" in
    nfs://*.sfs)
      mkdir -p /live
      nfs_host="${rootpart#nfs://}"
      nfs_path="${nfs_host#*/}"
      nfs_path="/${nfs_path%/*}"
      nfs_host="${nfs_host%%/*}"

      nfsmount -o intr,v3,udp "$nfs_host:$nfs_path" /live
      chained_mount ":${rootpart##*/}" "$mpt"
    ;;
    mem:*)
      mkdir -p /live
      chained_mount mem /live
      live_is_tmpfs=1
      chained_mount "${rootpart#mem:}" "$mpt"
    ;;
    [a-z]*://*) chained_mount "$rootpart" "$mpt" ;;
    [0-9a-z]*:/*) 
      nfsmount -o intr,v3,udp "$rootpart" "$mpt"
      add_chained_mpt "$mpt"
    ;;
    *) chained_mount $rootpart $mpt;;
  esac
}

union_parts () {
  local parts="$1" destdir="$2" aufs_dirs="" part
  
  log "Union $parts to $destdir"
  for part in $parts;do
    if test -z "$aufs_dirs";then
      mount -o remount,rw none $part
      aufs_dirs="$part=rw"
    else
      aufs_dirs="$aufs_dirs:$part=rr"
    fi
  done
  mount -t aufs -o dirs=$aufs_dirs aufs $destdir
  for part in $parts;do
    if mkdir -p $destdir/.parts/${part##*/};then
      mount -o move $part $destdir/.parts/${part##*/}
    fi
  done
}

mount_root() {
  local root="$1" rootpart mpt
  chained_parts=""

  for rootpart in $(str_split + $root);do
    mount_rootpart $rootpart
  done
  test -z "$live_is_tmpfs" || {
    for mpt in /live/mnt/*;do
      umount $mpt
      rmdir $mpt
    done
    rmdir /live/mnt
  }

  case "$chained_parts" in
    *" "*) union_parts "$chained_parts" $rr ;;
    *) mount -o move /parts/* $rr
  esac
}

run_parts() {
  local dir="$1"
  shift
  for script in "$dir"/*;do
    case "$script" in
      *.sh) . "$script";;
      *) test ! -x "$script" || "$script" "$@" ;;
    esac
  done
}

enter_stage () {
  set +x
  stage="$1"
  test -z "$verbose" || echo "[$stage]"
  test "$brk" != "$stage" || exit
  test "$verbose" != "$stage" || set -x
  test ! -r "/scripts/$stage" || . "/scripts/$stage"
  test ! -d "/scripts/$stage.d" || run_parts "/scripts/$stage.d"
}

init_env () {
  local cmd cmdline var val f
  test ! -r /cmdline || cmdlinefile=/cmdline
  read cmdline <${cmdlinefile:-/proc/cmdline}
  for cmd in $cmdline;do
    case "$cmd" in
      no_volid) no_volid=1 ;;
      quiet) quiet="1" qswitch="-q" ;;
      stderr=*) exec 2>${cmd#stderr=} ;;
      stdout=*) exec >${cmd#stdout=} ;;
      quiet=*) quiet="${cmd#quiet=}" qswitch="-q" ;;
      verbose=*|verbose) qswitch="-v" verbose="${cmd#verbose=}" ;;
      break=*) brk="${cmd#break=}" ;;
      break) brk="finalize" ;;
      *=*) eval "$cmd" || true;;
    esac
  done

  for f in /lib*/*-*/libnss_*;do
    if test -e "$f";then
      case "$LD_LIBRARY_PATH" in *${f%/*}*) continue;; esac
      export LD_LIBRARY_PATH="${LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:}${f%/*}"
    fi
  done
}


auto_root() {
  local devname
  for devname in $(list_partitions);do
    if test "$(fs_type "$devname")" = "crypto_LUKS";then
      if prepare_dev $devname && prepare_dev @ROOT 5;then
        root=$prepared_device
        break
      fi
    fi
  done
  test -n "$root" || {
    if prepare_dev @ROOT 5;then
      root=$prepared_device
    fi
  }
}

refresh_lvm() {
  rm -f /etc/lvm/cache/.cache
  lvm vgchange -a y
}

exit_trap() {
  echo "ramdisk init($0) exits. stage=$stage${brk:+ break=$brk}."
  test "${quiet:-0}" -gt 1 || { set -x ; set; }
  if test -x /bin/busybox;then
    exec /bin/busybox sh
  else
    exec /bin/sh
  fi
}
